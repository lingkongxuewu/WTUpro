C51 COMPILER V9.01   SENSOR                                                                06/01/2018 17:39:16 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SENSOR
OBJECT MODULE PLACED IN .\obj\Sensor.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\Sensor.c OPTIMIZE(SIZE) BROWSE INCDIR(.\inc) DEBUG OBJECTEXTEND PRINT(.
                    -\list\Sensor.lst) OBJECT(.\obj\Sensor.obj)

line level    source

   1          /*--------------------------------ÎÄ*¼þ*ÐÅ*Ï¢-----------------------------
   2          * ÎÄ¼þÃû£º  Sensor.c
   3          * °æ¡¡±¾£º  v1.0
   4          * Ãè  Êö£º  100TË«Öá ÕûºÏºóµÄ°æ±¾
   5          * ´´½¨ÈË£º  
   6          * ÈÕ  ÆÚ£º  
   7          --------------------------------------------------------------------------
   8          *µ±Ç°°æ±¾:      v1.0
   9          *ÐÞ ¸Ä ÈË:
  10          *ÈÕ¡¡  ÆÚ:
  11          ----------------------------------ÐÞ¸ÄÂÄÀú--------------------------------
  12          1¡¢
  13          2¡¢
  14          3¡¢
  15          4¡¢
  16          ------------------------------------------------------------------------*/
  17          #define __SENSOR_C__
  18          #include "_Include.h"
  19          
  20          //-------------define-----------------
  21          
  22          static int8u    xdata  filtercnt; //ÂË²¨ÏµÊý
  23          //static int32u xdata  adfnum;
  24          //***********************************************************************/
  25          // *¹¦    ÄÜ£ºÊý¾Ý³õÊ¼»¯
  26          // *Èë    ¿Ú£ºp_sn,sensor½á¹¹ÌåÖ¸Õë(X,Y);p_tempcal,temp_calib½á¹¹ÌåÖ¸Õë(ÎÂ²¹);
  27          //            p_angcal,ang_calib½á¹¹ÌåÖ¸Õë(½Ç¶È±ê¶¨)
  28          // *³ö    ¿Ú£º
  29          // *±¸    ×¢£º
  30          // *º¯ÊýÐÔÖÊ£º
  31          //***********************************************************************/
  32          static void Sn_DataInit(struct sensor *p_sn, struct temp_calib *p_tempcal, struct ang_calib *p_angcal)
  33          {
  34   1              p_sn->val=0;     //Ô­Ê¼Öµ
  35   1              p_sn->ftval=0;   //ÂË²¨Ö®ºóµÄÖµ
  36   1              p_sn->ftval_f=0;
  37   1              p_sn->oftval=0;  //ÎÂ²¹Ö®ºóµÄÖµ
  38   1              p_sn->ang=0;    //
  39   1              p_sn->tempcal=p_tempcal; //Ö¸Ïò½á¹¹Ìåtemp_xcal /Temp_Ycal
  40   1              p_sn->angcal=p_angcal;    //Ö¸Ïòang_xcal Ang_Ycal
  41   1      }
  42          
  43          //***********************************************************************/
  44          // *¹¦    ÄÜ£º´«¸ÐÆ÷ÖµÂË²¨
  45          // *Èë    ¿Ú£ºp_sn,sensor½á¹¹ÌåÖ¸Õë(X,Y);val,ÐÂÖµ;ftcnt£¬Ò»½×ÂË²¨ÏµÊý
  46          // *³ö    ¿Ú£º
  47          // *±¸    ×¢£ºADCÂË²¨ºóµÄÖµ
  48          // *º¯ÊýÐÔÖÊ£º
  49          //***********************************************************************/
  50          static void SnFilter(struct sensor *p_sn, int32u val, int8u ftcnt)
  51          {
  52   1          if(ValInRange(p_sn->ftval,val,(int32u)FILTER_XY))    //ÏÞ·ùÂË²¨
  53   1          {
  54   2              p_sn->ftval_f=Filter_1st(p_sn->ftval_f,val,ftcnt);     //Ò»½×ÖÍºóÂË²¨ 
C51 COMPILER V9.01   SENSOR                                                                06/01/2018 17:39:16 PAGE 2   

  55   2              
  56   2              p_sn->ftval=(int32u)(p_sn->ftval_f+0.5);                //ËÄÉáÎåÈë
  57   2              
  58   2          }
  59   1          else
  60   1              p_sn->ftval  =val;    //±ä»¯·ù¶È½Ï´ó£¬Ö±½ÓÐ´ÈëÐÂÖµ       
  61   1              p_sn->ftval_f=val;
  62   1      }
  63          
  64          //***********************************************************************/
  65          // *¹¦    ÄÜ£º»ñÈ¡ÎÂ²¹µÄ½Ç¶ÈÖµ
  66          // *Èë    ¿Ú£ºp_sn,sensor½á¹¹ÌåÖ¸Õë(X,Y);temp,ÎÂ¶ÈÖµ
  67          // *³ö    ¿Ú£ºÎÂ²¹Öµ
  68          // *±¸    ×¢£ºoffset=k*temp+a;
  69          // *º¯ÊýÐÔÖÊ£º
  70          //*********************************** ************************************/
  71          static int32s GetOffset(struct sensor *p_sn, int16u temp)
  72          {
  73   1          int8u xdata i;
  74   1          float xdata offset;
  75   1      
  76   1          for(i=0;i<(p_sn->tempcal->calcnt-2);i++)      //¸÷ÖáÎÂ¶ÈÐ£×¼µã¸öÊý  3
  77   1          {
  78   2              if(temp<(p_sn->tempcal->ptempval[i+1]))    //²éÕÒÎÂ¶ÈÔÚÎÂ²¹Ä£¿éÖÐÎÂ¶ÈÊý×éÖÐµÄÎ»ÖÃ
  79   2                  break;
  80   2          }
  81   1          offset =(int32s)( p_sn->tempcal->prm_k[i]*temp+p_sn->tempcal->prm_a[i]);    //»ñÈ¡ÏàÓ¦µÄK,AÖµ£¬²¢¼ÆËã
  82   1      
  83   1          return offset;
  84   1      }
  85          
  86          //***********************************************************************/
  87          // *¹¦    ÄÜ£º»ñÈ¡±ê¶¨ºóµÄ½Ç¶ÈÖµ
  88          // *Èë    ¿Ú£ºp_sn,sensor½á¹¹ÌåÖ¸Õë(X,Y);val,½Ç¶ÈµÄADCÖµ
  89          // *³ö    ¿Ú£º½Ç¶ÈÕýÏÒÖµ
  90          // *±¸    ×¢£ºang=k*ang_adc+a;                                                                                                                                                  
  91          // *º¯ÊýÐÔÖÊ£º
  92          //***********************************************************************/
  93          static float GetAngCalcVal(struct sensor *p_sn, int32u val)
  94          {
  95   1          int8u xdata i;
  96   1          float xdata tmp;
  97   1      
  98   1              for(i=0;i<(p_sn->angcal->calcnt-2);i++)
  99   1          {
 100   2              if(val<(p_sn->angcal->adcarr[i+1]))    //²éÕÒµ±Ç°½Ç¶ÈADCÖµÔÚ½Ç¶È±ê¶¨Ä£¿éÖÐADCÖµÊý×éÖÐµÄÎ»ÖÃ
 101   2                  break;
 102   2          }
 103   1          tmp = p_sn->angcal->prm_k[i]*val + p_sn->angcal->prm_a[i];    //»ñÈ¡ÏàÓ¦µÄK,AÖµ£¬²¢¼ÆËã
 104   1          return tmp;
 105   1      }
 106          
 107          //***********************************************************************/
 108          // *¹¦    ÄÜ£º½Ç¶È¼ÆËã
 109          // *Èë    ¿Ú£ºp_sn,sensor½á¹¹ÌåÖ¸Õë(X,Y);
 110          // *³ö    ¿Ú£º
 111          // *±¸    ×¢£º
 112          // *º¯ÊýÐÔÖÊ£º
 113          //***********************************************************************/
 114          static void Ang_Calc(struct sensor *p_sn)
 115          {
 116   1          float xdata ang;
C51 COMPILER V9.01   SENSOR                                                                06/01/2018 17:39:16 PAGE 3   

 117   1          ang=GetAngCalcVal(p_sn,p_sn->oftval);       //½Ç¶È±ê¶¨ºóµÄ½Ç¶ÈÕýÏÒÖµ
 118   1              switch(AngRange)
 119   1              {
 120   2                      case 30:
 121   2                      {
 122   3                              if(ang>=0.5)
 123   3                              p_sn->ang=300000;
 124   3                          else if(ang<=-0.5)          
 125   3                              p_sn->ang=-300000;
 126   3                          else
 127   3                          {
 128   4                              ang=asin(ang);
 129   4                              ang=ang/PI*1800000;
 130   4                              p_sn->ang=ang;
 131   4                          }
 132   3                      }
 133   2                      break;
 134   2                      case 15:
 135   2                      {
 136   3      //              Comm_PutInt32s(ang*10000);
 137   3      //              Comm_PutChar('\n');
 138   3      //              Comm_SendSta();
 139   3                              if(ang>=0.2588)
 140   3                              p_sn->ang=150000;
 141   3                          else if(ang<=-0.2588)
 142   3                              p_sn->ang=-150000;
 143   3                          else
 144   3                          {
 145   4                              ang=asin(ang);
 146   4                              ang=ang/PI*1800000;
 147   4                              p_sn->ang=ang;
 148   4                          }
 149   3                      }
 150   2                      break;
 151   2                      case 5:
 152   2                      {
 153   3                              if(ang>=0.0871)
 154   3                              p_sn->ang=50000;
 155   3                          else if(ang<=-0.0871)
 156   3                              p_sn->ang=-50000;       
 157   3                          else
 158   3                          {
 159   4                              ang=asin(ang);
 160   4                              ang=ang/PI*1800000;
 161   4                              p_sn->ang=ang;
 162   4                          }   
 163   3                      }
 164   2                      break;
 165   2              }
 166   1      }
 167          
 168          //***********************************************************************/
 169          // *¹¦    ÄÜ£º¼ÓËÙ¶È´«¸ÐÆ÷XÊý¾Ý³õÊ¼»¯
 170          // *±¸    ×¢£ºtemp_xcal£¬ÎÂ²¹Ä£¿é£»ang_xcal£¬½Ç¶È±ê¶¨Ä£¿é
 171          //***********************************************************************/
 172          void SnXDataInit(void)
 173          {
 174   1          Sn_DataInit(&accel_x,&Temp_Xcal,&Ang_Xcal);
 175   1      }
 176          void SnYDataInit(void)
 177          {
 178   1          Sn_DataInit(&accel_y,&Temp_Ycal,&Ang_Ycal);    //¼ÓËÙ¶È´«¸ÐÆ÷YÊý¾Ý³õÊ¼»¯
C51 COMPILER V9.01   SENSOR                                                                06/01/2018 17:39:16 PAGE 4   

 179   1      }
 180          void SnXFilter(int32u val, int8u ftcnt)
 181          {
 182   1          SnFilter(&accel_x,val,ftcnt);    //XÂË²¨
 183   1      }
 184          void SnYFilter(int32u val, int8u ftcnt)
 185          {
 186   1          SnFilter(&accel_y,val,ftcnt);    //yÂË²¨
 187   1      }
 188          int32s GetXOffset(int16u temp)
 189          {
 190   1          return(GetOffset(&accel_x,temp));    //XÎÂ²¹
 191   1      }
 192          int32s GetYOffset(int16u temp)
 193          {
 194   1          return(GetOffset(&accel_y,temp));    //YÎÂ²¹
 195   1      }
 196          void AngXCalc(void)
 197          {
 198   1          Ang_Calc(&accel_x);    //X½Ç¶È¼ÆËã
 199   1      }
 200          void AngYCalc(void)
 201          {
 202   1          Ang_Calc(&accel_y);    //Y½Ç¶È¼ÆËã
 203   1      }
 204          //***********************************************************************/
 205          // *¹¦    ÄÜ£º´«¸ÐÆ÷½á¹¹Ìå³õÊ¼»¯
 206          // *Èë    ¿Ú£º
 207          // *³ö    ¿Ú£º
 208          // *±¸    ×¢£º
 209          // *º¯ÊýÐÔÖÊ£º
 210          //***********************************************************************/
 211          void SnInit(void)
 212          {
 213   1          CalibInit();            //Ð£×¼Ä£¿é³õÊ¼»¯
 214   1          SetFilterCnt(4);        //
 215   1          accel_x.DataInit=SnXDataInit;
 216   1          accel_x.Filter=SnXFilter;
 217   1          accel_x.GetTempOffset=GetXOffset;
 218   1          accel_x.AngCalc=AngXCalc;
 219   1          accel_x.DataInit();
 220   1      
 221   1          accel_y.DataInit=SnYDataInit;
 222   1          accel_y.Filter=SnYFilter;
 223   1          accel_y.GetTempOffset=GetYOffset;
 224   1          accel_y.AngCalc=AngYCalc;
 225   1          accel_y.DataInit();
 226   1      }
 227          
 228          //***********************************************************************/
 229          // *¹¦    ÄÜ£º»ñÈ¡½Ç¶ÈµÄADÖµ£¨´°¿ÚÂË²¨ºó£©£¬½øÐÐÒ»½×ÂË²¨ºÍÎÂ¶È²¹³¥ £¬Ëã³ö½Ç¶ÈÖµ
 230          // *Èë    ¿Ú£º
 231          // *³ö    ¿Ú£º
 232          // *±¸    ×¢£º2013-6-9 10:47AMÒÑ¾­ÐÞ¸Ä
 233          // *º¯ÊýÐÔÖÊ£º
 234          //***********************************************************************/
 235          void SnProc(void)
 236          {    
 237   1              if(AdcEndTag==0)         return;
 238   1          AdcEndTag=0;
 239   1          
 240   1          switch(Adc_Flag)
C51 COMPILER V9.01   SENSOR                                                                06/01/2018 17:39:16 PAGE 5   

 241   1              {       case 0:
 242   2                                      accel_x.val=Adc_GetXVal();                                             //¶ÁÈ¡XÖáµÄ½Ç¶ÈADÖµ £¨´°¿ÚÂË²¨º
             -ó£©
 243   2                                      SnXFilter(accel_x.val,filtercnt);       //Ö±½Óµ÷ÓÃº¯Êý
 244   2                                      accel_x.oftval=(int32s)((int32s)accel_x.ftval+
 245   2                                      accel_x.GetTempOffset(Get_McuTemp()));  //ÎÂ¶È²¹³¢
 246   2                                      accel_x.AngCalc();                                      //¼ÆËã½Ç¶È£¨ÎÂ²¹ºó£©
 247   2                                      break;
 248   2                   case 1:
 249   2                              accel_y.val=Adc_GetYVal();                                             //¶ÁÈ¡XÖáµÄ½Ç¶ÈADÖµ £¨´°¿ÚÂ
             -Ë²¨ºó£©
 250   2                                      SnYFilter(accel_y.val,filtercnt);       //Ö±½Óµ÷ÓÃº¯Êý                             //Ò»½×ÂË²¨
 251   2                      accel_y.oftval=(int32s)((int32s)accel_y.ftval+
 252   2                                          accel_y.GetTempOffset(Get_McuTemp()));          //ÎÂ¶È²¹³¢            
             -                    
 253   2                                      accel_y.AngCalc();
 254   2                                      break;
 255   2                      default:
 256   2                                      break;               
 257   2              }
 258   1      }
 259          
 260          //***********************************************************************/
 261          // *¹¦    ÄÜ£º»ñÈ¡Ò»½×ÂË²¨ÏµÊý
 262          // *Èë    ¿Ú£º
 263          // *³ö    ¿Ú£ºÒ»½×ÂË²¨ÏµÊý
 264          // *±¸    ×¢£º
 265          // *º¯ÊýÐÔÖÊ£º
 266          //***********************************************************************/
 267          int8u GetFilterCnt(void)
 268          {
 269   1          return filtercnt;
 270   1      }
 271          //***********************************************************************/
 272          // *¹¦    ÄÜ£ºÉèÖÃÒ»½×ÂË²¨ÏµÊý
 273          // *Èë    ¿Ú£º
 274          // *³ö    ¿Ú£º
 275          // *±¸    ×¢£º
 276          // *º¯ÊýÐÔÖÊ£º
 277          //***********************************************************************/
 278          void SetFilterCnt(int8u cnt)
 279          {
 280   1          filtercnt=cnt;
 281   1      }
 282          
 283          //***********************************************************************/
 284          // *¹¦    ÄÜ£º»ñÈ¡µ±Ç°ÎÂ¶È
 285          // *Èë    ¿Ú£º
 286          // *³ö    ¿Ú£º
 287          // *±¸    ×¢£º
 288          // *º¯ÊýÐÔÖÊ£º
 289          //***********************************************************************/
 290          int16u Get_McuTemp(void)
 291          {
 292   1          return(Adc_GetTemp());      //MCUËù²âµÄÎÂ¶ÈÖµ
 293   1      }
 294          
 295          //***********************************************************************/
 296          // *¹¦    ÄÜ£º»ñÈ¡XÖáÒ»½×ÂË²¨ºóµÄÖµ
 297          // *Èë    ¿Ú£º
 298          // *³ö    ¿Ú£º
 299          // *±¸    ×¢£º
C51 COMPILER V9.01   SENSOR                                                                06/01/2018 17:39:16 PAGE 6   

 300          // *º¯ÊýÐÔÖÊ£º
 301          //***********************************************************************/
 302          int32u GetXFtVal(void)
 303          {
 304   1          return (accel_x.ftval);
 305   1      }
 306          
 307          //***********************************************************************/
 308          // *¹¦    ÄÜ£º»ñÈ¡YÖáÒ»½×ÂË²¨ºóµÄÖµ
 309          // *Èë    ¿Ú£º
 310          // *³ö    ¿Ú£º
 311          // *±¸    ×¢£º
 312          // *º¯ÊýÐÔÖÊ£º
 313          //***********************************************************************/
 314          int32u GetYFtVal(void)
 315          {
 316   1          return (accel_y.ftval);
 317   1      }
 318          
 319          //***********************************************************************/
 320          // *¹¦    ÄÜ£º»ñÈ¡XÖáÎÂ²¹ºóµÄÖµ
 321          // *Èë    ¿Ú£º
 322          // *³ö    ¿Ú£º
 323          // *±¸    ×¢£º
 324          // *º¯ÊýÐÔÖÊ£º
 325          //***********************************************************************/
 326          int32s GetXOftVal(void)
 327          {
 328   1          return (accel_x.oftval);
 329   1      }
 330          
 331          //***********************************************************************/
 332          // *¹¦    ÄÜ£º»ñÈ¡YÖáÎÂ²¹ºóµÄÖµ
 333          // *Èë    ¿Ú£º
 334          // *³ö    ¿Ú£º
 335          // *±¸    ×¢£º
 336          // *º¯ÊýÐÔÖÊ£º
 337          //***********************************************************************/
 338          int32s GetYOftVal(void)
 339          {
 340   1          return (accel_y.oftval);
 341   1      }
 342          
 343          //***********************************************************************/
 344          // *¹¦    ÄÜ£º»ñÈ¡XÖá½Ç¶ÈÖµ
 345          // *Èë    ¿Ú£º
 346          // *³ö    ¿Ú£º
 347          // *±¸    ×¢£º
 348          // *º¯ÊýÐÔÖÊ£º
 349          //***********************************************************************/
 350          int32s GetXAng(void)
 351          {
 352   1          return (accel_x.ang);
 353   1      }
 354          
 355          //***********************************************************************/
 356          // *¹¦    ÄÜ£º»ñÈ¡YÖá½Ç¶ÈÖµ
 357          // *Èë    ¿Ú£º
 358          // *³ö    ¿Ú£º
 359          // *±¸    ×¢£º
 360          // *º¯ÊýÐÔÖÊ£º
 361          //***********************************************************************/
C51 COMPILER V9.01   SENSOR                                                                06/01/2018 17:39:16 PAGE 7   

 362          int32s GetYAng(void)
 363          {
 364   1          return (accel_y.ang);
 365   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1512    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     77      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      42
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
